import React, { useState, useEffect } from 'react';
import backgroundImage from '@/assets/background1.jpg';  // ÂØºÂÖ•ÂõæÁâá
import { toast } from 'sonner';
import { useChatMessages } from '@/hooks/useChatMessages';
import { useStarMap } from '@/hooks/useStarMap';
import { callAI } from '@/services/aiService';
import { parseAIResponseForTasks } from '@/services/taskParsingService';
import { TaskSuggestion } from '@/types/taskSuggestion';
import ChatHeader from '@/components/chat/ChatHeader';
import MessageList from '@/components/chat/MessageList';
import ChatInput from '@/components/chat/ChatInput';

interface ChatPageProps {
  user: { id: string; username?: string };
  selectedAvatar: number;
  onSwipeLeft: () => void;
  onGoToStarMap: () => void;
  onLogout: () => void;
  onResetOnboarding: () => void;
}

const ChatPage: React.FC<ChatPageProps> = ({ 
  user, 
  selectedAvatar, 
  onSwipeLeft, 
  onGoToStarMap, 
  onLogout, 
  onResetOnboarding 
}) => {
  const [inputText, setInputText] = useState('');
  const [aiTyping, setAiTyping] = useState(false);
  const [showTodoCard, setShowTodoCard] = useState(false);
  const [taskSuggestions, setTaskSuggestions] = useState<TaskSuggestion[]>([]);
  const [showTaskSuggestions, setShowTaskSuggestions] = useState(false);
  const touchStartX = React.useRef<number>(0);
  
  const { messages, loading, addMessage, clearMessages, addWelcomeMessage } = useChatMessages(user.id);
  const { nodes, level, completeNode, getNodeByKeywords } = useStarMap(user.id);

  // Add welcome message if no messages exist
  useEffect(() => {
    if (!loading && messages.length === 0) {
      addWelcomeMessage();
    }
  }, [loading, messages.length, addWelcomeMessage]);

  // Ê£ÄÊµãÂÆåÊàêÂÖ≥ÈîÆËØçÂπ∂ÁÇπ‰∫ÆËäÇÁÇπ
  const checkForTaskCompletion = (userMessage: string) => {
    const completionKeywords = [
      ['ÂÆåÊàê', 'ÂÅöÂÆå', 'ÁªìÊùü', 'ÊêûÂÆö'],
      ['ËøêÂä®', 'ÈîªÁÇº', 'Ë∑ëÊ≠•', 'ÂÅ•Ë∫´'],
      ['Â≠¶‰π†', 'Áúã‰π¶', 'ÈòÖËØª', 'ÁªÉ‰π†'],
      ['Ê≤üÈÄö', '‰∫§ÊµÅ', 'ËØ¥ËØù', 'ËÅäÂ§©'],
      ['ÊÉÖÁª™', 'ÂøÉÊÉÖ', 'ÊÑüÂèó', 'ÂÜ•ÊÉ≥'],
      ['Èù¢ËØï', 'Â∑•‰Ωú', 'Ê±ÇËÅå', 'ÁÆÄÂéÜ']
    ];

    const foundKeywords: string[] = [];
    completionKeywords.forEach(keywordGroup => {
      keywordGroup.forEach(keyword => {
        if (userMessage.includes(keyword)) {
          foundKeywords.push(keyword);
        }
      });
    });

    if (foundKeywords.length > 0) {
      const matchedNode = getNodeByKeywords(foundKeywords);
      if (matchedNode && (matchedNode.status === 'available' || matchedNode.status === 'active')) {
        completeNode(matchedNode.id);
        return matchedNode;
      }
    }

    return null;
  };

  const handleSend = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!inputText.trim() || aiTyping) return;

    const userMessage = inputText.trim();
    setInputText('');
    
    // Ê£ÄÊü•‰ªªÂä°ÂÆåÊàê
    const completedNode = checkForTaskCompletion(userMessage);
    
    // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´ÂæÖÂäû‰∫ãÈ°πÁõ∏ÂÖ≥ÂÖ≥ÈîÆËØç
    const todoKeywords = ['ÂæÖÂäû', '‰ªªÂä°', 'todo', 'ËÆ°Âàí', 'ÂÆâÊéí', 'ÊèêÈÜí'];
    const shouldShowTodo = todoKeywords.some(keyword => 
      userMessage.toLowerCase().includes(keyword)
    );
    
    if (shouldShowTodo) {
      setShowTodoCard(true);
    }
    
    // Add user message with completed node info
    await addMessage(userMessage, true, completedNode);
    
    // Show AI typing indicator
    setAiTyping(true);
    
    try {
      let aiResponse = await callAI(userMessage);
      
      // Ëß£ÊûêAIÂõûÂ§ç‰∏≠ÁöÑ‰ªªÂä°Âª∫ËÆÆ
      const messageId = Date.now().toString();
      const parsedMessage = parseAIResponseForTasks(aiResponse, messageId);
      
      // Â¶ÇÊûúÊúâ‰ªªÂä°Âª∫ËÆÆÔºåÊòæÁ§∫‰ªªÂä°Âª∫ËÆÆÂç°Áâá
      if (parsedMessage.taskSuggestions.length > 0) {
        setTaskSuggestions(parsedMessage.taskSuggestions);
        setShowTaskSuggestions(true);
      }
      
      // ‰ΩøÁî®Ê∏ÖÁêÜÂêéÁöÑÊñáÊú¨‰Ωú‰∏∫AIÂõûÂ§ç
      let finalResponse = parsedMessage.text;
      
      // Â¶ÇÊûúÁî®Êà∑ÊèêÂà∞ÂæÖÂäû‰∫ãÈ°πÔºåAIÂõûÂ§ç‰∏≠‰πüÊèêÁ§∫ÂèØ‰ª•Êü•ÁúãÂæÖÂäûÂç°Áâá
      if (shouldShowTodo) {
        finalResponse += '\n\nüìù Êàë‰∏∫‰Ω†ÊòæÁ§∫‰∫ÜÂæÖÂäû‰∫ãÈ°πÂç°ÁâáÔºå‰Ω†ÂèØ‰ª•Áõ¥Êé•Âú®ËøôÈáåÊü•ÁúãÂíåÁÆ°ÁêÜ‰ªªÂä°„ÄÇ';
      }

      // Â¶ÇÊûúÊúâËäÇÁÇπË¢´ÁÇπ‰∫ÆÔºåAI‰ºöÁ•ùË¥∫
      if (completedNode) {
        finalResponse += `\n\nüéâ Â§™Ê£í‰∫ÜÔºÅ‰Ω†ÂàöÂàöÁÇπ‰∫Æ‰∫Ü„Äå${completedNode.name}„ÄçËäÇÁÇπÔºåÊàë‰ª¨ÁöÑÊòüÂõæÂèà‰∫Æ‰∫Ü‰∏ÄÈ¢óÊòüÔºÅÁªßÁª≠Âä†Ê≤πÔºåÊàë‰ª¨‰ºöË∂äÊù•Ë∂äÂº∫Â§ßÁöÑÔºÅ`;
      }
      
      await addMessage(finalResponse, false);
    } catch (error) {
      console.error('AIË∞ÉÁî®Â§±Ë¥•:', error);
      
      toast.error('AIÊúçÂä°ÊöÇÊó∂‰∏çÂèØÁî®ÔºåËØ∑Á®çÂêéÈáçËØï');
      
      const fallbackResponses = [
        "Êä±Ê≠âÔºåÊàëÁé∞Âú®Êó†Ê≥ïËøûÊé•Âà∞ÊúçÂä°Âô®„ÄÇËÆ©Êàë‰ª¨ÁªßÁª≠ËÅäÂ§©ÂêßÔºÅ",
        "ÁΩëÁªúËøûÊé•‰ºº‰πéÊúâÈóÆÈ¢òÔºå‰∏çËøáÊàë‰ªçÁÑ∂Âú®ËøôÈáåÈô™‰º¥‰Ω†„ÄÇ",
        "ÊäÄÊúØÈóÆÈ¢òÊöÇÊó∂ÈòªÁ¢ç‰∫ÜÊàëÔºå‰ΩÜËøô‰∏çÂΩ±ÂìçÊàë‰ª¨ÁöÑÂØπËØù„ÄÇ"
      ];
      
      const randomResponse = fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)];
      await addMessage(randomResponse, false);
    } finally {
      setAiTyping(false);
    }
  };

  const handleTaskComplete = async (taskTitle: string) => {
    const rewards = [
      `üéâ Â§™Ê£í‰∫ÜÔºÅ‰Ω†ÂàöÂàöÂÆåÊàê‰∫Ü„Äå${taskTitle}„ÄçÔºåÊàëËÉΩÊÑüÂèóÂà∞‰Ω†ÁöÑÂä™ÂäõÔºÅÊàë‰ª¨ÂèàÂêëÂâçËøàËøõ‰∫Ü‰∏ÄÊ≠•ÔºÅ`,
      `‚ú® Âπ≤ÂæóÊºÇ‰∫ÆÔºÅÂÆåÊàê„Äå${taskTitle}„ÄçËÆ©Êàë‰ª¨ÈÉΩÂèòÂæóÊõ¥Âº∫Â§ß‰∫ÜÔºÅÊØè‰∏Ä‰∏™Â∞èË°åÂä®ÈÉΩÂú®ÁßØÁ¥ØÂäõÈáèÔºÅ`,
      `üåü ÂÆåÊàêÂæóÂæàÂ•ΩÔºÅ„Äå${taskTitle}„ÄçÁöÑÊàêÂäüËÆ©Êàë‰πü‰∏∫‰Ω†ÊÑüÂà∞È™ÑÂÇ≤ÔºåÁªßÁª≠‰øùÊåÅËøô‰ªΩÂùöÊåÅÔºÅ`,
      `üí™ ÁúüÊòØÂ§™Ê£í‰∫ÜÔºÅ„Äå${taskTitle}„ÄçÁöÑÂÆåÊàêÂÖÖÊª°‰∫Ü‰Ω†ÁöÑÂÜ≥ÂøÉÔºå‰Ω†ÁöÑÂùöÊåÅ‰πüËÆ©ÊàëÂÖÖÊª°‰∫ÜÂäõÈáèÔºÅ`,
      `üéØ ‰ªªÂä°ÂÆåÊàêÔºÅÈÄöËøá„Äå${taskTitle}„ÄçÊàë‰ª¨Ê≠£Âú®‰∏ÄÊ≠•Ê≠•Êàê‰∏∫Êõ¥Â•ΩÁöÑËá™Â∑±ÔºÅËøôÂ∞±ÊòØÊàë‰ª¨ÁöÑËã±ÈõÑ‰πãË∑ØÔºÅ`
    ];
    const randomReward = rewards[Math.floor(Math.random() * rewards.length)];
    await addMessage(randomReward, false);
  };

  const handleClearChat = async () => {
    if (window.confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâËÅäÂ§©ËÆ∞ÂΩïÂêóÔºü')) {
      await clearMessages();
      toast.success('ËÅäÂ§©ËÆ∞ÂΩïÂ∑≤Ê∏ÖÁ©∫');
    }
  };

  const handleTouchStart = (e: React.TouchEvent) => {
    touchStartX.current = e.touches[0].clientX;
  };

  const handleTouchEnd = (e: React.TouchEvent) => {
    const touchEndX = e.changedTouches[0].clientX;
    const diff = touchStartX.current - touchEndX;
    
    if (diff > 50) { // Â∑¶Êªë
      onSwipeLeft();
    }
  };

  if (loading) {
    return (
      <div className="mobile-container bg-white flex items-center justify-center">
        <div className="text-gray-600">Âä†ËΩΩËÅäÂ§©ËÆ∞ÂΩï‰∏≠...</div>
      </div>
    );
  }

  return (
    <div 
      className="mobile-container bg-white flex flex-col h-screen"
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      style=    {{backgroundImage: `url(${backgroundImage})`,
    backgroundSize: 'cover',
    backgroundPosition: 'center'}}
    >
      <ChatHeader
        selectedAvatar={selectedAvatar}
        onAvatarClick={onLogout}
        onClearChat={handleClearChat}
        onOnboardingClick={onResetOnboarding}
        onGoToStarMap={onGoToStarMap}
      />

      <MessageList
        messages={messages}
        aiTyping={aiTyping}
        showTodoCard={showTodoCard}
        starMapLevel={level}
        taskSuggestions={taskSuggestions}
        showTaskSuggestions={showTaskSuggestions}
        onCloseTodoCard={() => setShowTodoCard(false)}
        onGoToTodoList={onSwipeLeft}
        onGoToStarMap={onGoToStarMap}
        onCloseTaskSuggestions={() => setShowTaskSuggestions(false)}
        onTaskComplete={handleTaskComplete}
      />

      <ChatInput
        inputText={inputText}
        aiTyping={aiTyping}
        onInputChange={setInputText}
        onSubmit={handleSend}
        onGoToTodoList={onSwipeLeft}
      />
    </div>
  );
};

export default ChatPage;
