
import React, { useState, useEffect } from 'react';
import backgroundImage from '@/assets/background1.jpg';  // ÂØºÂÖ•ÂõæÁâá
import { toast } from 'sonner';
import { useChatMessages } from '@/hooks/useChatMessages';
import { useStarMap } from '@/hooks/useStarMap';
import { callAI, generateQuestions } from '@/services/aiService';
import { parseAIResponseForTasks } from '@/services/taskParsingService';
import { TaskSuggestion } from '@/types/taskSuggestion';
import ChatHeader from '@/components/chat/ChatHeader';
import MessageList from '@/components/chat/MessageList';
import ChatInput from '@/components/chat/ChatInput';

interface ChatPageProps {
  user: { id: string; username?: string };
  selectedAvatar: number;
  onSwipeLeft: () => void;
  onGoToStarMap: () => void;
  onLogout: () => void;
  onResetOnboarding: () => void;
}

const ChatPage: React.FC<ChatPageProps> = ({ 
  user, 
  selectedAvatar, 
  onSwipeLeft, 
  onGoToStarMap, 
  onLogout, 
  onResetOnboarding 
}) => {
  const [inputText, setInputText] = useState('');
  const [aiTyping, setAiTyping] = useState(false);
  const [showTodoCard, setShowTodoCard] = useState(false);
  const [taskSuggestions, setTaskSuggestions] = useState<TaskSuggestion[]>([]);
  const [showTaskSuggestions, setShowTaskSuggestions] = useState(false);
  const [questionSuggestions, setQuestionSuggestions] = useState<string[]>([]);
  const [showQuestionSuggestions, setShowQuestionSuggestions] = useState(false);
  const touchStartX = React.useRef<number>(0);
  
  const { messages, loading, addMessage, clearMessages, addWelcomeMessage } = useChatMessages(user.id);
  const { nodes, level, completeNode, getNodeByKeywords } = useStarMap(user.id);

  // ‰øÆÊîπÊ¨¢ËøéÊ∂àÊÅØÈÄªËæë
  useEffect(() => {
    if (!loading) {
      addWelcomeMessage();
    }
  }, [loading, addWelcomeMessage]);

  // Ê£ÄÊµãÂÆåÊàêÂÖ≥ÈîÆËØçÂπ∂ÁÇπ‰∫ÆËäÇÁÇπ - Áî®‰∫é‰ªªÂä°ÂÆåÊàêÂêéÁöÑÊ£ÄÊü•
  const checkForTaskCompletion = (taskTitle: string) => {
    const completionKeywords = [
      // ÂøÉÁêÜ‰ºòÂäøÁõ∏ÂÖ≥
      ['ÂèçÊÄù', 'ÊÄùËÄÉ', 'ÊÄªÁªì', 'Ê¢≥ÁêÜ', 'ÂàÜÊûê'],
      ['ÊÉÖÁª™', 'ÂøÉÊÉÖ', 'ÊÑüÂèó', 'Ë∞ÉËäÇ'],
      ['Ëá™‰ø°', '‰ø°ÂøÉ', '‰ª∑ÂÄº', 'ËÇØÂÆö'],
      ['ÂéãÂäõ', 'ÊîæÊùæ', 'ÂáèÂéã', 'ÁºìËß£'],
      
      // Ë∫´‰ΩìÂÅ•Â∫∑Áõ∏ÂÖ≥
      ['ËøêÂä®', 'ÈîªÁÇº', 'Ë∑ëÊ≠•', 'ÂÅ•Ë∫´', 'Áëú‰ºΩ'],
      ['È•ÆÈ£ü', 'Ëê•ÂÖª', 'ÂêÉ', 'È£üÁâ©'],
      ['Áù°Áú†', '‰ºëÊÅØ', '‰ΩúÊÅØ'],
      ['‰ΩìÈáç', 'ÂáèËÇ•', 'Áß∞Èáç'],
      ['‰ΩìËÉΩ', '‰ΩìÂäõ', 'ËÄêÂäõ'],
      
      // ÊäÄËÉΩÂèëÂ±ïÁõ∏ÂÖ≥
      ['Èù¢ËØï', 'Ê±ÇËÅå', 'Â∫îËÅò', 'ÂáÜÂ§á'],
      ['Ê≤üÈÄö', '‰∫§ÊµÅ', 'Ë°®Ëææ', 'Ë∞àËØù'],
      ['ËÅå‰∏ö', 'ËßÑÂàí', 'ÂèëÂ±ï'],
      ['ÁÆÄÂéÜ', 'Â±•ÂéÜ', 'CV'],
      ['Á§º‰ª™', 'ËÅåÂú∫', 'ÂïÜÂä°']
    ];

    const foundKeywords: string[] = [];
    completionKeywords.forEach(keywordGroup => {
      keywordGroup.forEach(keyword => {
        if (taskTitle.includes(keyword)) {
          foundKeywords.push(keyword);
        }
      });
    });

    if (foundKeywords.length > 0) {
      const matchedNode = getNodeByKeywords(foundKeywords);
      if (matchedNode && (matchedNode.status === 'available' || matchedNode.status === 'active')) {
        completeNode(matchedNode.id);
        return matchedNode;
      }
    }

    return null;
  };

  const handleSend = async (e: React.FormEvent, messageText?: string) => {
    e.preventDefault();
    
    // ‰ΩøÁî®‰º†ÂÖ•ÁöÑÊ∂àÊÅØÊñáÊú¨ÊàñËæìÂÖ•Ê°ÜÊñáÊú¨
    const userMessage = messageText || inputText.trim();
    if (!userMessage || aiTyping) return;

    setInputText('');
    
    // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´ÂæÖÂäû‰∫ãÈ°πÁõ∏ÂÖ≥ÂÖ≥ÈîÆËØç
    const todoKeywords = ['ÂæÖÂäû', '‰ªªÂä°', 'todo', 'ËÆ°Âàí', 'ÂÆâÊéí', 'ÊèêÈÜí'];
    const shouldShowTodo = todoKeywords.some(keyword => 
      userMessage.toLowerCase().includes(keyword)
    );
    
    if (shouldShowTodo) {
      setShowTodoCard(true);
    }
    
    // Add user message without any star map completion logic
    await addMessage(userMessage, true, null);
    
    // Show AI typing indicator
    setAiTyping(true);
    
    try {
      let aiResponse = await callAI(userMessage);
      
      // Ëß£ÊûêAIÂõûÂ§ç‰∏≠ÁöÑ‰ªªÂä°Âª∫ËÆÆ
      const messageId = Date.now().toString();
      const parsedMessage = parseAIResponseForTasks(aiResponse, messageId);
      
      // Â¶ÇÊûúÊúâ‰ªªÂä°Âª∫ËÆÆÔºåÊòæÁ§∫‰ªªÂä°Âª∫ËÆÆÂç°Áâá
      if (parsedMessage.taskSuggestions.length > 0) {
        setTaskSuggestions(parsedMessage.taskSuggestions);
        setShowTaskSuggestions(true);
      }
      
      // ‰ΩøÁî®Ê∏ÖÁêÜÂêéÁöÑÊñáÊú¨‰Ωú‰∏∫AIÂõûÂ§ç
      let finalResponse = parsedMessage.text;
      
      // Â¶ÇÊûúÁî®Êà∑ÊèêÂà∞ÂæÖÂäû‰∫ãÈ°πÔºåAIÂõûÂ§ç‰∏≠‰πüÊèêÁ§∫ÂèØ‰ª•Êü•ÁúãÂæÖÂäûÂç°Áâá
      if (shouldShowTodo) {
        finalResponse += '\n\nüìù Êàë‰∏∫‰Ω†ÊòæÁ§∫‰∫ÜÂæÖÂäû‰∫ãÈ°πÂç°ÁâáÔºå‰Ω†ÂèØ‰ª•Áõ¥Êé•Âú®ËøôÈáåÊü•ÁúãÂíåÁÆ°ÁêÜ‰ªªÂä°„ÄÇ';
      }

      await addMessage(finalResponse, false);
      
      // ÁîüÊàêÈóÆÈ¢òÂª∫ËÆÆ
      try {
        const questions = await generateQuestions(userMessage, finalResponse);
        if (questions.length > 0) {
          setQuestionSuggestions(questions);
          setShowQuestionSuggestions(true);
        }
      } catch (error) {
        console.error('ÁîüÊàêÈóÆÈ¢òÂª∫ËÆÆÂ§±Ë¥•:', error);
      }
    } catch (error) {
      console.error('AIË∞ÉÁî®Â§±Ë¥•:', error);
      
      toast.error('AIÊúçÂä°ÊöÇÊó∂‰∏çÂèØÁî®ÔºåËØ∑Á®çÂêéÈáçËØï');
      
      const fallbackResponses = [
        "Êä±Ê≠âÔºåÊàëÁé∞Âú®Êó†Ê≥ïËøûÊé•Âà∞ÊúçÂä°Âô®„ÄÇËÆ©Êàë‰ª¨ÁªßÁª≠ËÅäÂ§©ÂêßÔºÅ",
        "ÁΩëÁªúËøûÊé•‰ºº‰πéÊúâÈóÆÈ¢òÔºå‰∏çËøáÊàë‰ªçÁÑ∂Âú®ËøôÈáåÈô™‰º¥‰Ω†„ÄÇ",
        "ÊäÄÊúØÈóÆÈ¢òÊöÇÊó∂ÈòªÁ¢ç‰∫ÜÊàëÔºå‰ΩÜËøô‰∏çÂΩ±ÂìçÊàë‰ª¨ÁöÑÂØπËØù„ÄÇ"
      ];
      
      const randomResponse = fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)];
      await addMessage(randomResponse, false);
    } finally {
      setAiTyping(false);
    }
  };

  // Êñ∞Â¢ûÔºöÂ§ÑÁêÜÈóÆÈ¢òÁÇπÂáªÔºåÁõ¥Êé•ÂèëÈÄÅËÄå‰∏çÊòØÂ§çÂà∂Âà∞ËæìÂÖ•Ê°Ü
  const handleQuestionClick = async (question: string) => {
    setShowQuestionSuggestions(false);
    // Áõ¥Êé•ÂèëÈÄÅÈóÆÈ¢òÔºå‰∏çÈúÄË¶ÅÁî®Êà∑ÂÜçÊ¨°ÁÇπÂáªÂèëÈÄÅ
    const mockEvent = { preventDefault: () => {} } as React.FormEvent;
    await handleSend(mockEvent, question);
  };

  // Â§ÑÁêÜ‰ªªÂä°ÂÆåÊàê - ËøôÈáåÊòØÁúüÊ≠£ÁöÑ‰ªªÂä°ÂÆåÊàêÊó∂Êú∫Ôºå‰ºöËß¶ÂèëÂ∫ÜÁ•ùÂíåÊòüÂõæÁÇπ‰∫Æ
  const handleTaskComplete = async (taskTitle: string) => {
    // ÂÖàÂÖ≥Èó≠‰ªªÂä°Âª∫ËÆÆÂç°ÁâáÔºåËÆ©Â∫ÜÁ•ùÊ∂àÊÅØÊòæÁ§∫Âú®‰∏ãÊñπ
    setShowTaskSuggestions(false);
    
    // Ê£ÄÊü•ÊòØÂê¶ÁÇπ‰∫ÆÊòüÂõæËäÇÁÇπ
    const completedNode = checkForTaskCompletion(taskTitle);
    
    // ÂèëÈÄÅÂ∫ÜÁ•ùÊ∂àÊÅØ
    const rewards = [
      `üéâ Â§™Ê£í‰∫ÜÔºÅ‰Ω†ÂàöÂàöÂÆåÊàê‰∫Ü„Äå${taskTitle}„ÄçÔºåÊàëËÉΩÊÑüÂèóÂà∞‰Ω†ÁöÑÂä™ÂäõÔºÅÊàë‰ª¨ÂèàÂêëÂâçËøàËøõ‰∫Ü‰∏ÄÊ≠•ÔºÅ`,
      `‚ú® Âπ≤ÂæóÊºÇ‰∫ÆÔºÅÂÆåÊàê„Äå${taskTitle}„ÄçËÆ©Êàë‰ª¨ÈÉΩÂèòÂæóÊõ¥Âº∫Â§ß‰∫ÜÔºÅÊØè‰∏Ä‰∏™Â∞èË°åÂä®ÈÉΩÂú®ÁßØÁ¥ØÂäõÈáèÔºÅ`,
      `üåü ÂÆåÊàêÂæóÂæàÂ•ΩÔºÅ„Äå${taskTitle}„ÄçÁöÑÊàêÂäüËÆ©Êàë‰πü‰∏∫‰Ω†ÊÑüÂà∞È™ÑÂÇ≤ÔºåÁªßÁª≠‰øùÊåÅËøô‰ªΩÂùöÊåÅÔºÅ`,
      `üí™ ÁúüÊòØÂ§™Ê£í‰∫ÜÔºÅ„Äå${taskTitle}„ÄçÁöÑÂÆåÊàêÂÖÖÊª°‰∫Ü‰Ω†ÁöÑÂÜ≥ÂøÉÔºå‰Ω†ÁöÑÂùöÊåÅ‰πüËÆ©ÊàëÂÖÖÊª°‰∫ÜÂäõÈáèÔºÅ`,
      `üéØ ‰ªªÂä°ÂÆåÊàêÔºÅÈÄöËøá„Äå${taskTitle}„ÄçÊàë‰ª¨Ê≠£Âú®‰∏ÄÊ≠•Ê≠•Êàê‰∏∫Êõ¥Â•ΩÁöÑËá™Â∑±ÔºÅËøôÂ∞±ÊòØÊàë‰ª¨ÁöÑËã±ÈõÑ‰πãË∑ØÔºÅ`
    ];
    const randomReward = rewards[Math.floor(Math.random() * rewards.length)];
    await addMessage(randomReward, false);

    // Â¶ÇÊûúÊúâËäÇÁÇπË¢´ÁÇπ‰∫ÆÔºåÊòæÁ§∫ÊòüÂõæËäÇÁÇπÂÆåÊàêÂç°Áâá
    if (completedNode) {
      await addMessage(
        `üéâ Â§™Ê£í‰∫ÜÔºÅ‰Ω†ÂàöÂàöÁÇπ‰∫Æ‰∫Ü„Äå${completedNode.name}„ÄçËäÇÁÇπÔºåÊàë‰ª¨ÁöÑÊòüÂõæÂèà‰∫Æ‰∫Ü‰∏ÄÈ¢óÊòüÔºÅÁªßÁª≠Âä†Ê≤πÔºåÊàë‰ª¨‰ºöË∂äÊù•Ë∂äÂº∫Â§ßÁöÑÔºÅ`,
        false,
        completedNode
      );
    }
  };

  const handleClearChat = async () => {
    if (window.confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâËÅäÂ§©ËÆ∞ÂΩïÂêóÔºü')) {
      await clearMessages();
      toast.success('ËÅäÂ§©ËÆ∞ÂΩïÂ∑≤Ê∏ÖÁ©∫');
    }
  };

  const handleTouchStart = (e: React.TouchEvent) => {
    touchStartX.current = e.touches[0].clientX;
  };

  const handleTouchEnd = (e: React.TouchEvent) => {
    const touchEndX = e.changedTouches[0].clientX;
    const diff = touchStartX.current - touchEndX;
    
    if (diff > 50) { // Â∑¶Êªë
      onSwipeLeft();
    }
  };

  if (loading) {
    return (
      <div className="mobile-container bg-white flex items-center justify-center">
        <div className="text-gray-600">Âä†ËΩΩËÅäÂ§©ËÆ∞ÂΩï‰∏≠...</div>
      </div>
    );
  }

  return (
    <div 
      className="mobile-container bg-white flex flex-col h-screen"
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      style={{
        backgroundImage: `url(${backgroundImage})`,
        backgroundSize: 'cover',
        backgroundPosition: 'center'
      }}
    >
      <ChatHeader
        selectedAvatar={selectedAvatar}
        onAvatarClick={onLogout}
        onClearChat={handleClearChat}
        onOnboardingClick={onResetOnboarding}
        onGoToStarMap={onGoToStarMap}
      />

      <MessageList
        messages={messages}
        aiTyping={aiTyping}
        showTodoCard={showTodoCard}
        starMapLevel={level}
        taskSuggestions={taskSuggestions}
        showTaskSuggestions={showTaskSuggestions}
        questionSuggestions={questionSuggestions}
        showQuestionSuggestions={showQuestionSuggestions}
        onCloseTodoCard={() => setShowTodoCard(false)}
        onGoToTodoList={onSwipeLeft}
        onGoToStarMap={onGoToStarMap}
        onCloseTaskSuggestions={() => setShowTaskSuggestions(false)}
        onCloseQuestionSuggestions={() => setShowQuestionSuggestions(false)}
        onQuestionClick={handleQuestionClick}
        onTaskComplete={handleTaskComplete}
      />

      <ChatInput
        inputText={inputText}
        aiTyping={aiTyping}
        onInputChange={setInputText}
        onSubmit={handleSend}
        onGoToTodoList={onSwipeLeft}
      />
    </div>
  );
};

export default ChatPage;
